{
  "id": "dvyhdf",
  "directive": "Create implementation plan from discussion: \"I want to build a package based system for locus where community can build their own packages and publish npm and then install and then use them with a similar interface. For example, first package I will be building is telegram package where telegram can be used for remote control our agent. The packages should be installed with locus install command and there should be a proper version control similar to casual npm packages. Then I should call locus pkg telegram and use it with the other available commands built by the package itself. Then we will showcase those packages in our marketplace so that people can use it\"\n\nDISCUSSION CONTENT:\n# I want to build a package based system for locus where community can build their own packages and publish npm and then install and then use them with a similar interface. For example, first package I will be building is telegram package where telegram can be used for remote control our agent. The packages should be installed with locus install command and there should be a proper version control similar to casual npm packages. Then I should call locus pkg telegram and use it with the other available commands built by the package itself. Then we will showcase those packages in our marketplace so that people can use it\n\n**Date:** 2026-02-26\n**Provider:** claude / sonnet\n\n---\n\nNow I have a thorough picture of the codebase. Let me write the full architectural analysis.\n\n---\n\n## Architectural Analysis: Locus Package System\n\n---\n\n### 1. Context\n\nLocus currently ships as a monolithic CLI (`@locusai/cli`) — a single bundled `bin/locus.js` with a hardcoded switch-router in `packages/cli/src/cli.ts:303-430`. Every command is statically known at build time.\n\nThe goal is to let the **community** ship new capabilities (e.g., Telegram remote control, Slack alerts, Jira sync, custom AI tools) as independent npm packages that integrate cleanly into the `locus` CLI without forking or patching the core. The first package is a Telegram remote-control bridge (`locus-telegram`).\n\nThis matters because:\n- Locus's value multiplies with ecosystem breadth\n- Community-built integrations are hard to maintain in core\n- A marketplace creates network effects and virality\n- The Telegram use-case (remote control an agent from your phone) is genuinely compelling\n\nThe key constraint: **the CLI is compiled to a single flat `bin/locus.js` via Bun**. Traditional Node.js plugin systems (`require()` from a relative `node_modules/`) do not work with bundled outputs without special handling.\n\n---\n\n### 2. Options\n\n#### Option A — Subprocess Binary Delegation\n\nPackages publish npm packages with a binary entry (`locus-telegram`, `locus-slack`). The core CLI discovers installed packages and delegates via `child_process.spawn`.\n\n```\nlocus install locus-telegram      # writes to ~/.locus/packages.json, runs npm install\nlocus pkg telegram start          # resolves binary path, spawns subprocess\n```\n\n**Pros:**\n- No bundling problem — packages are separate processes\n- Any language can write a package (Go, Rust, Python)\n- Zero version conflict between core and packages\n- Clean isolation; a crashing package can't kill the main process\n- Consistent with how VS Code extensions, kubectl plugins, and git sub-commands work\n\n**Cons:**\n- No in-process access to `config`, `logger`, `github.ts`, or `runAI()` — packages must reimplement or call locus via subprocess\n- Bidirectional communication requires IPC setup (socket or stdin/stdout protocol)\n- Startup latency per invocation\n\n---\n\n#### Option B — Dynamic Node Module Loading at Runtime\n\nPackages install to `~/.locus/packages/node_modules/`. At startup, `cli.ts` enumerates installed packages and dynamically imports their manifests.\n\n```typescript\n// Package exports\nexport const manifest: LocusPackageManifest = {\n  name: \"telegram\",\n  commands: { start: { handler: async (args, api) => { ... } } }\n}\n```\n\n**Pros:**\n- Packages can call into locus API directly (config, logger, GitHub)\n- Feels like an extension, not a subprocess\n\n**Cons:**\n- `bin/locus.js` is a Bun bundle — `import()` paths inside it resolve relative to the bundle, not `~/.locus/`. This requires explicit path resolution via `createRequire(import.meta.url)` or `importShim` tricks that are brittle\n- Packages must use same versions of shared code as core (tight coupling)\n- A package crash or infinite loop kills the CLI process\n- Security: arbitrary code runs in the same process as the user's AI agent\n\n---\n\n#### Option C — Subprocess with Structured IPC (Hybrid)\n\nPackages run as subprocesses but communicate bidirectionally with the core over a Unix socket or stdin/stdout JSON-RPC protocol. The core exposes an `@locusai/sdk` with an `IPC client` that packages use to call back into locus functions (run an issue, stream AI output, etc.).\n\n```\nPackage → JSON-RPC request → Locus core socket → execute → stream response back\n```\n\n**Pros:**\n- Best of A and B: isolation + rich API access\n- Telegram package could trigger `run issue 42` by calling the IPC API and stream results back to Telegram\n\n**Cons:**\n- Significant protocol complexity to build and maintain\n- Socket lifecycle management (per-invocation? persistent daemon?)\n- Over-engineered for v1\n\n---\n\n#### Option D — Shell Script / Thin Wrapper Packages\n\nPackages are just shell scripts. `locus pkg telegram` sources/runs scripts that call `locus run`, `locus exec`, etc. as normal CLI invocations.\n\n**Pros:** Trivially simple, no infrastructure needed\n\n**Cons:** No streaming, no typed API, packages can't receive AI output programmatically, dead-end architecture\n\n---\n\n### 3. Recommendation\n\n**Start with Option A (Subprocess Binary Delegation), design the protocol to evolve toward Option C.**\n\nHere's the reasoning specific to this codebase:\n\n1. **The bundle constraint is real.** `bun build src/cli.ts --outfile bin/locus.js` produces a sealed artifact. Dynamic module loading inside a Bun bundle requires workarounds that break at runtime. Subprocess delegation sidesteps this entirely.\n\n2. **The Telegram use-case is a long-running daemon**, not a one-shot command. `locus pkg telegram start` should launch a persistent bot process. This is naturally a subprocess — it runs until killed, and it uses its own event loop to poll Telegram. Trying to do this in-process inside the locus CLI would be awkward.\n\n3. **The kubectl/git plugin model is proven.** `git credential-<helper>`, `kubectl plugin <name>`, `docker compose` — the ecosystem is full of CLI plugin systems that work via `PATH`-resolution of named binaries. Users understand it.\n\n4. **Protocol envelope for IPC can be added incrementally.** For v1, packages can invoke `locus run <issue>` as a shell command. For v2, expose a local HTTP or socket API for richer integration (streaming agent output to Telegram, etc.).\n\n---\n\n### 4. Trade-offs\n\n| What We Gain | What We Sacrifice |\n|---|---|\n| Clean isolation between core and community packages | Packages can't natively call `runAI()`, `loadConfig()`, or `github.ts` without either re-invoking `locus` as a subprocess or waiting for an IPC layer |\n| Community can build in any language | TypeScript packages get the nicest DX with `@locusai/sdk` |\n| Core CLI stays small and stable | Package authors bear the cost of cross-process communication |\n| Marketplace is purely about discovery, not a runtime dependency | Version upgrades require `locus install --upgrade` or `locus upgrade pkg` |\n| No bundle headaches | Slight startup overhead per `locus pkg` invocation |\n\n---\n\n### 5. Implementation Notes\n\n#### 5.1 Package Convention\n\nPackages follow the naming convention `locus-<name>` on npm and expose a binary of the same name:\n\n```json\n// locus-telegram/package.json\n{\n  \"name\": \"locus-telegram\",\n  \"version\": \"1.0.0\",\n  \"bin\": { \"locus-telegram\": \"bin/index.js\" },\n  \"keywords\": [\"locusai-package\"],\n  \"locus\": {\n    \"displayName\": \"Telegram\",\n    \"description\": \"Remote control locus agent via Telegram\",\n    \"commands\": [\"start\", \"stop\", \"status\", \"config\"]\n  }\n}\n```\n\nThe `\"locus\"` field in `package.json` is the **package manifest** — used by the marketplace and by `locus pkg --help` to auto-generate help text without executing the package.\n\n#### 5.2 `locus install` Command\n\n```\npackages/cli/src/commands/install.ts\n```\n\n```typescript\nexport async function installCommand(projectRoot, args, flags) {\n  const packageName = args[0] // \"locus-telegram\" or \"@org/locus-telegram\"\n  const registry = loadPackageRegistry()  // ~/.locus/packages.json\n\n  // 1. Resolve package name → normalize to \"locus-<name>\" if user typed just \"telegram\"\n  // 2. Run: bun add <packageName> in ~/.locus/packages/ (o",
  "sprint": null,
  "createdAt": "2026-02-26T03:24:52.932Z",
  "issues": [
    {
      "order": 1,
      "title": "Define package registry types and global package storage structure",
      "body": "## Overview\n\nEstablish the foundational data structures, file layout, and TypeScript types for the Locus package system. All subsequent issues depend on this.\n\n## Background\n\nLocus needs a persisted registry at `~/.locus/packages.json` that tracks installed packages, their versions, and their resolved binary paths. The package convention is `locus-<name>` on npm with a `\"locus\"` metadata field in `package.json` describing its commands.\n\n## Tasks\n\n- [ ] Create `packages/cli/src/packages/types.ts` with the following exported types:\n  - `LocusPackageManifest` — shape of the `\"locus\"` field inside a package's `package.json` (`displayName`, `description`, `commands: string[]`, `version`)\n  - `LocusPackageRegistryEntry` — a single installed package record (`name`, `version`, `installedAt`, `binaryPath`, `manifest: LocusPackageManifest`)\n  - `LocusPackageRegistry` — the full registry file shape (`{ packages: Record<string, LocusPackageRegistryEntry> }`)\n- [ ] Create `packages/cli/src/packages/registry.ts` with helper functions:\n  - `getPackagesDir(): string` — returns `~/.locus/packages/` (created if missing)\n  - `getRegistryPath(): string` — returns `~/.locus/packages/registry.json`\n  - `loadRegistry(): LocusPackageRegistry` — reads and parses `registry.json`; returns empty registry if not found\n  - `saveRegistry(registry: LocusPackageRegistry): void` — writes registry atomically\n  - `resolvePackageBinary(packageName: string): string | null` — given a short name like `\"telegram\"`, resolves the full path to the binary inside `~/.locus/packages/node_modules/.bin/locus-telegram`\n- [ ] The `~/.locus/packages/` directory must have its own `package.json` (with `{ \"private\": true }`) so that `npm`/`bun` can install packages into it without affecting the user's project\n- [ ] Add a helper `normalizePackageName(input: string): string` that converts `\"telegram\"` → `\"locus-telegram\"` and passes through already-prefixed names unchanged\n\n## Acceptance Criteria\n\n- All types are exported from a single barrel at `packages/cli/src/packages/index.ts`\n- `loadRegistry()` gracefully handles a missing or malformed `registry.json` by returning `{ packages: {} }`\n- `getPackagesDir()` creates the directory and seeds a `package.json` if neither exists\n- TypeScript compiles with zero errors\n- Unit tests cover `normalizePackageName` edge cases: short name, already-prefixed name, scoped package (`@org/locus-telegram`)",
      "priority": "critical",
      "type": "feature",
      "dependsOn": "none"
    },
    {
      "order": 2,
      "title": "Implement `locus install` command for npm-based package installation",
      "body": "## Overview\n\nAdd the `locus install <package>` command that installs a community package from npm into `~/.locus/packages/`, registers it in the local registry, and reports the installed version.\n\n## Background\n\nPackages are standard npm packages named `locus-<name>`. Installation must:\n1. Normalize the name (e.g., `telegram` → `locus-telegram`)\n2. Run `npm install` (or `bun add`) in `~/.locus/packages/`\n3. Read the installed package's `package.json` to extract version and the `\"locus\"` manifest field\n4. Persist the registry entry\n\n## Tasks\n\n- [ ] Create `packages/cli/src/commands/install.ts` exporting `installCommand(args: string[], flags: Record<string, string>)`\n- [ ] Accept an optional `--version` / `-v` flag to pin a specific version (e.g., `locus install telegram --version 1.2.3`)\n- [ ] Accept an optional `--upgrade` / `-u` flag to upgrade an already-installed package to latest (or the pinned version)\n- [ ] Spawn `npm install <packageName>@<version>` in `~/.locus/packages/` using `child_process.spawnSync` with `stdio: 'inherit'` so progress is shown to the user\n- [ ] After installation, read `~/.locus/packages/node_modules/<packageName>/package.json` to extract `version` and `locus` manifest fields\n- [ ] Validate that the installed package contains a `\"locus\"` field; warn (but do not error) if it is missing, since non-locus packages might still be useful\n- [ ] Resolve the binary path via `resolvePackageBinary()` and store it in the registry entry\n- [ ] Write the updated registry via `saveRegistry()`\n- [ ] Print a success summary: package name, version installed, available commands from manifest\n- [ ] Handle error cases: package not found on npm (non-zero exit code), network failure, missing binary after install\n- [ ] Wire `install` into `packages/cli/src/cli.ts` command router under the key `\"install\"`\n\n## Acceptance Criteria\n\n- `locus install telegram` installs `locus-telegram@latest` and prints the version and commands\n- `locus install locus-telegram@1.0.0` or `locus install telegram --version 1.0.0` installs the pinned version\n- `locus install telegram` when already installed prints an \"already installed\" message and exits cleanly (unless `--upgrade` is passed)\n- `locus install telegram --upgrade` upgrades to the latest version and updates the registry\n- Registry entry is present in `~/.locus/packages/registry.json` after install with correct `name`, `version`, `binaryPath`, `installedAt`, and `manifest`\n- Running `locus install nonexistent-package-xyz` fails gracefully with a clear error message",
      "priority": "critical",
      "type": "feature",
      "dependsOn": "1"
    },
    {
      "order": 3,
      "title": "Implement `locus pkg <name> [command] [args...]` dispatcher",
      "body": "## Overview\n\nAdd the `locus pkg` command that looks up an installed package in the registry, resolves its binary, and delegates execution to it as a subprocess. This is the primary user-facing entrypoint for all package commands.\n\n## Background\n\nArchitectural decision: **subprocess binary delegation** (Option A from the analysis). The core CLI never loads package code in-process. Instead, it spawns the package binary and inherits stdio so the package has full terminal control.\n\n## Tasks\n\n- [ ] Create `packages/cli/src/commands/pkg.ts` exporting `pkgCommand(args: string[], flags: Record<string, string>)`\n- [ ] Parse the first positional argument as the package short name (e.g., `telegram`)\n- [ ] Look up the package in the registry via `loadRegistry()`; if not found, print an error suggesting `locus install <name>` and exit with code 1\n- [ ] Resolve the binary path from the registry entry's `binaryPath`; verify the file exists on disk (guard against manual deletions)\n- [ ] Spawn the binary with all remaining args forwarded: `spawn(binaryPath, remainingArgs, { stdio: 'inherit', env: { ...process.env, LOCUS_PKG: '1' } })`\n- [ ] Forward the subprocess exit code as the `locus pkg` process exit code\n- [ ] If no sub-command is provided (i.e., `locus pkg telegram` with no args), either spawn with no args (letting the package print its own help) or synthesize `--help`\n- [ ] Implement `locus pkg` with no arguments to list all installed packages: name, version, description, and available commands sourced from the registry manifest\n- [ ] Wire `pkg` into `packages/cli/src/cli.ts` command router\n- [ ] Handle SIGINT propagation: when the user presses Ctrl+C, send SIGINT to the child process before exiting\n\n## Acceptance Criteria\n\n- `locus pkg telegram start` resolves the `locus-telegram` binary and spawns it with `[\"start\"]` as args\n- The terminal is fully handed off (colors, interactive input, TUI all work)\n- Exit code of `locus pkg` matches the exit code of the spawned binary\n- `locus pkg telegram` with no sub-command triggers the package's help output\n- `locus pkg` with no package name lists all installed packages with version and description\n- `locus pkg unknownpkg` prints `Package 'unknownpkg' is not installed. Run: locus install unknownpkg` and exits 1\n- Ctrl+C during a long-running package command (e.g., a daemon) terminates the child process cleanly",
      "priority": "critical",
      "type": "feature",
      "dependsOn": "1, 2"
    },
    {
      "order": 4,
      "title": "Implement `locus uninstall` and `locus packages list` management commands",
      "body": "## Overview\n\nRound out the package lifecycle with uninstall and list commands so users can manage their installed packages without manually editing `~/.locus/packages/registry.json`.\n\n## Tasks\n\n- [ ] Create `packages/cli/src/commands/uninstall.ts` exporting `uninstallCommand(args: string[], flags: Record<string, string>)`:\n  - Normalize the package name\n  - Check registry; error if not installed\n  - Run `npm uninstall <packageName>` in `~/.locus/packages/`\n  - Remove the entry from the registry and call `saveRegistry()`\n  - Print confirmation: `Uninstalled locus-telegram v1.0.0`\n- [ ] Extend the `locus pkg` list output (from issue 3) to also be accessible via `locus packages` or `locus packages list` as a canonical alias\n- [ ] Add `locus packages outdated` subcommand:\n  - For each installed package, query `npm view <packageName> version` to get the latest published version\n  - Compare with installed version and print a table of packages with available upgrades\n- [ ] Wire `uninstall` and `packages` into `packages/cli/src/cli.ts` command router\n- [ ] Add `locus install --list` as an alias for `locus packages list` for discoverability\n\n## Acceptance Criteria\n\n- `locus uninstall telegram` removes `locus-telegram` from `node_modules` and the registry\n- `locus uninstall nonexistent` fails gracefully with an error\n- `locus packages list` prints a formatted table of all installed packages with name, version, description\n- `locus packages outdated` correctly identifies packages where `installedVersion !== latestVersion`\n- After uninstall, `locus pkg telegram` prints the \"not installed\" error rather than trying to spawn a missing binary",
      "priority": "high",
      "type": "feature",
      "dependsOn": "2, 3"
    },
    {
      "order": 5,
      "title": "Publish `@locusai/sdk` package for community package authors",
      "body": "## Overview\n\nCreate and publish an `@locusai/sdk` npm package that gives community package authors type definitions, utilities, and documentation for building Locus-compatible packages.\n\n## Background\n\nPackage authors need to know:\n- What the `\"locus\"` manifest field should contain\n- How to invoke `locus` sub-commands from their package (via `child_process`)\n- How to read Locus config (project token, GitHub repo, etc.) without importing from `@locusai/cli` internals\n- A standard way to parse args and print output consistently\n\n## Tasks\n\n- [ ] Create `packages/sdk/` as a new workspace package in the monorepo with `package.json` name `@locusai/sdk`\n- [ ] Export the following from `packages/sdk/src/index.ts`:\n  - `LocusPackageManifest` type (re-exported from a shared types package or duplicated if needed)\n  - `LocusConfig` type — the shape of the locus config that packages can read\n  - `readLocusConfig(cwd?: string): LocusConfig` — reads `~/.locus/config.json` and the project's `.locus/config.json` and merges them\n  - `invokeLocus(args: string[]): Promise<{ stdout: string; stderr: string; exitCode: number }>` — spawns the `locus` binary with the given args and returns captured output\n  - `invokeLocusStream(args: string[]): ChildProcess` — like above but returns the raw `ChildProcess` for streaming\n  - `createLogger(name: string)` — returns a simple structured logger consistent with locus output style\n- [ ] Add a `PACKAGE_GUIDE.md` in `packages/sdk/` explaining the naming convention, manifest format, how to test locally with `npm link`, and how to publish\n- [ ] Configure `tsconfig` and `build` script so the package compiles to CJS + ESM dual output\n- [ ] Add the SDK to the monorepo's `workspaces` in root `package.json`\n- [ ] Publish to npm as a public package (manual step — document in `PACKAGE_GUIDE.md`)\n\n## Acceptance Criteria\n\n- `@locusai/sdk` can be installed standalone: `npm install @locusai/sdk`\n- `readLocusConfig()` returns the merged config without throwing when config files are absent\n- `invokeLocus(['run', '42'])` spawns `locus run 42` and resolves with captured output\n- All exports are correctly typed and documented with JSDoc\n- The package builds cleanly with no TypeScript errors\n- `PACKAGE_GUIDE.md` contains a minimal end-to-end example of a working Locus package",
      "priority": "high",
      "type": "feature",
      "dependsOn": "1"
    },
    {
      "order": 6,
      "title": "Build `locus-telegram` reference package for remote agent control",
      "body": "## Overview\n\nCreate the first official Locus community package: `locus-telegram`. It runs as a persistent Telegram bot that lets users remotely control their Locus agent from their phone — triggering runs, checking status, and receiving output notifications.\n\n## Background\n\nThis package is both a useful product feature and the reference implementation that demonstrates best practices for package authors. It is a **long-running daemon process** (`locus pkg telegram start`) that polls the Telegram Bot API and maps incoming messages to `locus` CLI invocations.\n\n## Tasks\n\n- [ ] Create a new repository or monorepo package `locus-telegram` (to be published as `locus-telegram` on npm)\n- [ ] `package.json` must include:\n  - `\"bin\": { \"locus-telegram\": \"bin/index.js\" }`\n  - `\"keywords\": [\"locusai-package\"]`\n  - `\"locus\": { \"displayName\": \"Telegram\", \"description\": \"...\", \"commands\": [\"start\", \"stop\", \"status\", \"config\"] }`\n- [ ] Implement `bin/index.js` as a CLI entry that dispatches to sub-commands based on `process.argv[2]`:\n  - `start` — starts the Telegram bot daemon; reads bot token from `~/.locus/packages/locus-telegram/config.json` or env var `TELEGRAM_BOT_TOKEN`\n  - `stop` — sends SIGTERM to a running daemon (PID stored in `~/.locus/packages/locus-telegram/daemon.pid`)\n  - `status` — prints whether the daemon is running\n  - `config set token <TOKEN>` — saves the bot token to the local config file\n- [ ] Telegram bot command handlers (mapped from Telegram `/commands`):\n  - `/run <issue-number>` — calls `invokeLocus(['run', issueNumber])` from `@locusai/sdk` and replies with the output summary\n  - `/status` — replies with current locus status (pending issues, running jobs)\n  - `/stop` — gracefully stops the current running agent\n  - `/help` — lists available commands\n- [ ] Use `node-telegram-bot-api` or the raw Telegram Bot API via `fetch` for bot communication\n- [ ] The daemon must handle SIGTERM and SIGINT gracefully, flushing any in-progress state before exit\n- [ ] Write a `README.md` with setup instructions: creating a Telegram bot via BotFather, configuring the token, starting the daemon\n\n## Acceptance Criteria\n\n- `locus install telegram` installs the package successfully\n- `locus pkg telegram config set token <TOKEN>` saves the token\n- `locus pkg telegram start` starts the bot and prints `Telegram bot started. Send /help to your bot.`\n- Sending `/run 42` to the Telegram bot triggers `locus run 42` and replies with a summary\n- `locus pkg telegram stop` terminates the daemon\n- `locus pkg telegram status` correctly reports running/stopped\n- The package's `package.json` `\"locus\"` field is correctly read by `locus packages list`",
      "priority": "high",
      "type": "feature",
      "dependsOn": "3, 5"
    },
    {
      "order": 7,
      "title": "Build Locus Package Marketplace web page",
      "body": "## Overview\n\nCreate a marketplace page on the Locus website (or as a standalone page) where community members can discover, preview, and install Locus packages. The marketplace is powered by npm registry metadata filtered by the `locusai-package` keyword.\n\n## Background\n\nDiscoverability is the key network effect driver. The marketplace must be low-friction to publish to (just push to npm with the right keyword) and easy to browse for users.\n\n## Tasks\n\n- [ ] Create a marketplace data fetcher that queries the npm registry API for packages with `keywords:locusai-package`:\n  - Endpoint: `https://registry.npmjs.org/-/v1/search?text=keywords:locusai-package&size=100`\n  - Extract: `name`, `description`, `version`, `date`, `links.npm`, download counts\n  - Parse the `\"locus\"` manifest field from each package's full metadata if available\n- [ ] Design and implement the marketplace UI (React component or static page) with:\n  - Search/filter bar to filter packages by name or description\n  - Package cards showing: name, description, version, install command (`locus install <name>`), author, last updated\n  - A \"copy install command\" button on each card\n  - Sort options: most downloaded, recently updated, alphabetical\n- [ ] Highlight official/verified packages (e.g., `locus-telegram` by `@locusai`) with a badge\n- [ ] Add a \"Submit your package\" section linking to the `PACKAGE_GUIDE.md` from the SDK and explaining the naming convention and keyword requirement\n- [ ] Implement build-time or ISR data fetching so the page does not need to hit npm at runtime on every request (cache for 1 hour)\n- [ ] Ensure the install command shown is the short form: `locus install telegram` (not `locus install locus-telegram`)\n\n## Acceptance Criteria\n\n- The marketplace page lists all packages tagged with `locusai-package` keyword on npm\n- `locus-telegram` appears in the marketplace with correct metadata after it is published\n- The install command shown on each card is copy-pasteable and works correctly\n- The page renders correctly on mobile\n- Data is cached so npm API is not hammered on every page load\n- A \"Submit your package\" guide is linked from the page",
      "priority": "medium",
      "type": "feature",
      "dependsOn": "5, 6"
    }
  ]
}